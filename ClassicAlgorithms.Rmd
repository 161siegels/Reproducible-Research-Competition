---
title: "ClassicAlgorithms"
author: "Spencer Siegel"
date: "9/2/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
if(!require(dplyr)) {install.packages("dplyr", repos="http://cran.us.r-project.org"); library(dplyr)}
if(!require(tidyverse)) {install.packages("tidyverse", repos="http://cran.us.r-project.org"); library(tidyverse)}
if(!require(zoo)) {install.packages("zoo", repos="http://cran.us.r-project.org"); library(zoo)}
if(!require(data.table)) {install.packages("data.table", repos="http://cran.us.r-project.org"); library(data.table)}
if(!require(MASS)) {install.packages("MASS", repos="http://cran.us.r-project.org"); library(MASS)}
if(!require(randomForest)) {install.packages("randomForest", repos="http://cran.us.r-project.org"); library(randomForest)}
if(!require(Ckmeans.1d.dp)) {install.packages("Ckmeans.1d.dp", repos="http://cran.us.r-project.org"); library(Ckmeans.1d.dp)}
if(!require(DAAG)) {install.packages("DAAG", repos="http://cran.us.r-project.org"); library(DAAG)}
if(!require(e1071)) {install.packages("e1071", repos="http://cran.us.r-project.org"); library(e1071)}
if(!require(splines)) {install.packages("splines", repos="http://cran.us.r-project.org"); library(splines)}
if(!require(readr)) {install.packages("readr", repos="http://cran.us.r-project.org"); library(readr)}
if(!require(class)) {install.packages("class", repos="http://cran.us.r-project.org"); library(class)}
if(!require(xgboost)) {install.packages("xgboost", repos="http://cran.us.r-project.org"); library(xgboost)}
if(!require(mlr)) {install.packages("mlr", repos="http://cran.us.r-project.org"); library(mlr)}
if(!require(parallelMap)) {install.packages("parallelMap", repos="http://cran.us.r-project.org"); library(parallelMap)}
if(!require(parallel)) {install.packages("parallel", repos="http://cran.us.r-project.org"); library(parallel)}
if(!require(cluster)) {install.packages("cluster", repos="http://cran.us.r-project.org"); library(cluster)}
if(!require(factoextra)) {install.packages("factoextra", repos="http://cran.us.r-project.org"); library(factoextra)}
if(!require(gridExtra)) {install.packages("gridExtra", repos="http://cran.us.r-project.org"); library(gridExtra)}
if(!require(cluster)) {install.packages("cluster", repos="http://cran.us.r-project.org"); library(cluster)}
if(!require(mclust)) {install.packages("mclust", repos="http://cran.us.r-project.org"); library(mclust)}
library(gridExtra)
library(lme4)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
```{r}
data2= read_csv("cleaned_data.csv")
set.seed(1305)
train<-data2 %>% group_by(player_name) %>% sample_frac(.7)
test = anti_join(data2, train)
mod<-glm(SHOT_RESULT2~ LOCATION+GAME_CLOCK2+SHOT_CLOCK+DRIBBLES+TOUCH_TIME+SHOT_DIST+PTS_TYPE+CLOSE_DEF_DIST+FG_Percent+FG3_Percent+SHOT_NUMBER+FT_Percent+ratio+End_SC+End_PC+Quick_S+Clutch_T+Garbage_T+PERIOD+point_diff+jump_shot+putback+layup+bank+dunk+driving+tip+pullup+fadeaway+running+hook+reverse+turnaround+fingerroll,data=train,family="binomial")
summary(mod)
p=predict(mod, newdata = test, type = "response")
yhat=as.numeric(p>.525)
paste("Accuracy is ", 1-mean(yhat!= test[,"SHOT_RESULT2"]))

paste("Baseline Accuracy is ",1-mean(data2$SHOT_RESULT2))
```

```{r}
#scale data
scaled_data=dplyr::select(data2,SHOT_RESULT2,LOCATION,GAME_CLOCK2,SHOT_CLOCK,DRIBBLES,TOUCH_TIME,SHOT_DIST,PTS_TYPE,CLOSE_DEF_DIST,FG_Percent,FG3_Percent,SHOT_NUMBER,FT_Percent,ratio,End_SC,End_PC,Quick_S,Clutch_T,Garbage_T,PERIOD,point_diff,jump_shot,putback,layup,bank,dunk,driving,tip,pullup,fadeaway,running,hook,reverse,turnaround,fingerroll,player_name)
scaled_data$LOCATION=as.factor(scaled_data$player_name)
scaled_data$player_name=as.factor(scaled_data$player_name)
scaled_data[-1]<-lapply(scaled_data[-1],function(x) c(scale(as.numeric(x))))
scaled_data$SHOT_RESULT2<-as.factor(scaled_data$SHOT_RESULT2)
set.seed(1305)
scaled_train<-scaled_data %>% group_by(player_name) %>% sample_frac(.7)
scaled_test = anti_join(scaled_data, scaled_train)
scaled_train=scaled_train[,!(names(scaled_train) %in% c("player_name"))]
scaled_test=scaled_test[,!(names(scaled_test) %in% c("player_name"))]

traintask <- makeClassifTask (data = scaled_train,target = "SHOT_RESULT2")
testtask <- makeClassifTask (data = scaled_test,target = "SHOT_RESULT2")
lrn <- makeLearner("classif.xgboost", predict.type="response")
lrn$par.vals <- list(objective="binary:logistic", eval_metric="error", nrounds=100L, eta=0.1)
params <- makeParamSet(makeIntegerParam("max_depth", lower=3L, upper=20L), makeNumericParam("min_child_weight", lower=1L, upper=20L),
                       makeNumericParam("subsample", lower=0.2, upper=1), makeNumericParam("colsample_bytree", lower=0.2, upper=1))

rdesc <- makeResampleDesc("CV", stratify = T, iters=5L)
ctrl <- makeTuneControlRandom(maxit = 10L)
parallelStartSocket(cpus = detectCores())

mytune <- tuneParams(learner=lrn, task=traintask, resampling=rdesc, measures=acc, par.set=params, control=ctrl, show.info=T)

#xgboost with turned parameters
lrn_tune <- setHyperPars(lrn,par.vals = mytune$x)
xgmodel <- train(learner = lrn_tune,task = traintask)
xgpred <- predict(xgmodel,testtask)

confusion(xgpred$data$response,xgpred$data$truth)
(xgb.tune_error <- sum(xgpred$data$truth!=xgpred$data$response) / nrow(xgpred$data))
(xgb.tune.acc <- 1-xgb.tune_error)
```

```

